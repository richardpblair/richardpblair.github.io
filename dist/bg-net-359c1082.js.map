{
  "version": 3,
  "file": "bg-net-359c1082.js",
  "sources": [
    "assets/js/bg-net.js"
  ],
  "sourcesContent": [
    "let initialized = false;\n\nexport function initBGNet() {\n  if (initialized) return;\n  const canvas = document.getElementById('bg-net');\n  if (!canvas) return;\n\n  const lowPowerQuery = window.matchMedia('(max-width: 480px), (pointer: coarse)');\n  if (lowPowerQuery.matches) {\n    canvas.dataset.bgNetDisabled = 'true';\n    return;\n  }\n\n  if (document.visibilityState === 'hidden') {\n    const onVisible = () => {\n      document.removeEventListener('visibilitychange', onVisible);\n      initBGNet();\n    };\n    document.addEventListener('visibilitychange', onVisible, { once: true });\n    return;\n  }\n\n  initialized = true;\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return;\n  }\n\n  // === NEW: perf helpers ===\n  const DPR = Math.min(window.devicePixelRatio || 1, 1.5);   // clamp DPI\n  \n  // ========================== TUNING PANEL ==========================\n  const CONFIG = {\n    density: 0.00007,         // overall dot count (per pixel)\n    layers: [                 // depth layers (front first)\n      { speed: 0.70, size: [1.6, 2.4], linkDist: 160, linkAlpha: 0.30 },\n      { speed: 0.45, size: [1.5, 2.1], linkDist: 140, linkAlpha: 0.24 },\n      { speed: 0.30, size: [1.3, 1.8], linkDist: 120,  linkAlpha: 0.20 }\n    ],\n    fieldScale: 0.005,        // flow field \"frequency\" (lower = broader waves)\n    fieldSpeed: 0.00025,      // how fast the field moves through time\n    parallax: 0.45,            // mouse sway\n    dotColorA: '#FFD166',     // gradient start\n    dotColorB: '#F5B000',     // gradient end\n    lineColor: '#FFDF8A',     // ALPHA replaced dynamically\n    glow: 14,                 // shadowBlur for glowing dots/lines (0 to disable)\n    containToRegion: true,    // keep particles inside region\n    drawTriangles: false,     // set true to add triangle mesh accents\n    triangleAlpha: 0.05,      // opacity of triangle fill when enabled\n    flowStrength: 0.05,       // you said 0.05 — this is the multiplier for fx/fy\n    damping: 0.99,            // 0.96–0.99; higher = smoother\n    jitter: 0.002,            // set to 0.001–0.003 if you want subtle randomness\n    containMode: 'wrapX',     // 'wrapX' wraps left↔right; 'wrap' wraps both axes\n    wallMargin: 10,           // only used by 'steer' (Option B)\n    wallForce: 0.1,          // only used by 'steer' (Option B)\n    maxSpeed: 0.55,            // how fast are the particles moving\n    keepConnected: true,      // turn on nearest-neighbor fallback\n    kNearest: 1,              // guarantee up to 2 links per particle\n    minLinkAlpha: 0.16,       // floor opacity so fallbacks are visible\n    extraReach: 10,           // optional +reach for fallback links (px)\n    // --- depth setting ---\n    depthEnabled: true,\n    depthSizeRange: [0.70, 2.00], // multiply particle radius by lerp(min,max,z)\n    depthAlphaRange: [0.45, 1.00],// fade distant dots a bit\n    depthBlurMax: 2.2,            // max px blur for farthest dots (0 = off)\n    depthLinkWidth: [0.6, 2.6],   // line width range (far→near)\n    depthLinkAlphaBoost: 0.25,    // add up to +0.15 alpha for very near links\n    depthSpeedScale: [0.85, 1.12], // optional: near = a hair faster\n    // Distribution: >1 biases toward NEAR (more large close dots)\n    depthZBias: 1.8,\n    // Parallax (camera-ish feel)\n    parallaxEnabled: true,\n    parallaxStrength: 50,   // px shift for z=1 at screen edge\n    parallaxFollow: 0.10,   // smoothing (0.04–0.12 feels nice)\n    // --- twinkle settings ---\n    twinkleEnabled: true,     // master switch\n    twinkleSpeed: 6.0,        // how fast they shimmer (Hz)\n    twinkleDepthBoost: 0.99,   // extra sparkle for near (z=1)\n    twinkleIntensity: 0.45,    // 0.2–0.5 is subtle, >0.6 is flashy\n    // --- metallic specular settings ---\n    lightDir: { x: -0.6, y: -0.4 }, // direction the \"light\" comes from (left/up)\n    specularSize: 1.5,             // highlight radius as a factor of particle radius\n    specularScale: 0.65,            // how bright the specular can get (0.3–0.8)\n    specularWarmth: 0.15,           // adds a hint of warm gold into the highlight\n    // optional sparkle “star” on peak twinkles\n    sparkleThreshold: 0.92,         // trigger when twinkle > 92%\n    sparkleSize: 2.0,               // star arm length factor (× particle radius)\n    // --- link runners (data packets) ---\n    runnersEnabled: true,  // master switch\n    runnersPerLink: 1.5,     // 1–2 keeps it tasteful\n    runnerSpeed: 0.85,     // higher = faster travel along lines\n    runnerSize: 6.0,       // base radius in px (depth scales it)\n    runnerGlow: 8,         // shadowBlur for glow\n    runnerColor: '#FFD44D',// warm gold streak\n    runnerTail: 0.16,       // 0.08–0.16 fraction of the link as a “streak”\n    runnersEnabled: window.innerWidth >= 768, // off on mobile\n    twinkleEnabled: window.innerWidth >= 768, // off on mobile\n  \n  };\n  \n  // Respect prefers-reduced-motion (force calm mode)\n  const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n  if (reduceMotion) {\n    CONFIG.runnersEnabled = false;\n    CONFIG.twinkleEnabled = false;\n    CONFIG.glow = Math.min(CONFIG.glow, 6);\n    CONFIG.layers.forEach(l => { l.linkDist = Math.min(l.linkDist, 110); });\n  }\n  \n  \n  // Region modes: 'full' | 'right' | 'topRight' | 'custom'\n  let regionMode = 'right';\n  const customRegionPercents = { xMin: 0.6, xMax: 1.0, yMin: 0.00, yMax: 1.0 };\n  \n  // ======================== INTERNAL STATE ==========================\n  let W, H, rafId = 0, t = 0, lastTs = 0;\n  const pauseReasons = new Set();\n  const manualPauseKey = \"manual\";\n\n  const updateLoop = () => {\n    if (pauseReasons.size > 0) {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = 0;\n      }\n      return;\n    }\n    if (!rafId) {\n      rafId = requestAnimationFrame(step);\n    }\n  };\n\n  const setPaused = (reason, value) => {\n    if (value) {\n      pauseReasons.add(reason);\n    } else {\n      pauseReasons.delete(reason);\n    }\n    updateLoop();\n  };\n\n  let REGION = { xMin: 0, xMax: 0, yMin: 0, yMax: 0 };\n  let particles = []; // flat array of particles across all layers\n  let layerIndexOffsets = []; // where each layer starts in particles[]\n  let drawOrder = []; // sorted indices for draw order (far → near)\n  let mouse = { x: 0.7, y: 0.3, sx: 0.7, sy: 0.3 }; // screen-normalized; s* = smoothed\n  addEventListener('pointermove', (e) => {\n    const r = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - r.left) / r.width;\n    mouse.y = (e.clientY - r.top) / r.height;\n  });\n  \n  // ------------------------- Utilities ------------------------------\n  const rand = (min, max) => Math.random() * (max - min) + min;\n  const pairRand = (i, j) => {\n    const s = Math.sin(i * 12.9898 + j * 78.233 + 0.1234);\n    return Math.abs(s) % 1;\n  };\n  \n      // Deterministic seed per pair, stable over frames\n  function pairSeed(a, b) {\n    // swap-safe key: combine indexes\n    const x = Math.min(a,b), y = Math.max(a,b);\n    // simple hash → 0..1\n    const s = Math.sin(x * 12.345 + y * 98.765) * 43758.5453;\n    return Math.abs(s % 1);\n  }\n  \n  // 0..1 linear interpolation helper\n  const lerp = (a, b, t) => a + (b - a) * t;\n  \n  // Smooth pseudo-noise (fast value noise with bilinear interpolation)\n  function hash(x, y) {\n    // deterministic small hash\n    return Math.sin(x * 127.1 + y * 311.7) * 43758.5453 % 1;\n  \n  }\n  function valueNoise(x, y) {\n    const xi = Math.floor(x), yi = Math.floor(y);\n    const xf = x - xi,      yf = y - yi;\n    const tl = hash(xi, yi),   tr = hash(xi + 1, yi);\n    const bl = hash(xi, yi + 1), br = hash(xi + 1, yi + 1);\n    const u = xf * xf * (3 - 2 * xf);   // smoothstep\n    const v = yf * yf * (3 - 2 * yf);\n    const top = tl + u * (tr - tl);\n    const bot = bl + u * (br - bl);\n    return top + v * (bot - top); // 0..1\n  }\n  \n  function flowVec(x, y, time, scale, speed) {\n    // angle from noise → smooth direction\n    const angle = 6.28318 * valueNoise((x + time * speed) * scale,\n                                       (y - time * speed) * scale);\n    return { vx: Math.cos(angle), vy: Math.sin(angle) };\n  }\n  \n  function computeRegionPixels() {\n    const pct = (() => {\n      switch (regionMode) {\n        case 'right':    return { xMin: 0.70, xMax: 1.00, yMin: 0.00, yMax: 1.00 };\n        case 'topRight': return { xMin: 0.70, xMax: 1.00, yMin: 0.00, yMax: 0.45 };\n        case 'full':     return { xMin: 0.00, xMax: 1.00, yMin: 0.00, yMax: 1.00 };\n        case 'custom':   return customRegionPercents;\n        default:         return { xMin: 0.70, xMax: 1.00, yMin: 0.00, yMax: 1.00 };\n      }\n    })();\n    REGION.xMin = Math.floor(innerWidth  * pct.xMin);\n    REGION.xMax = Math.floor(innerWidth  * pct.xMax);\n    REGION.yMin = Math.floor(innerHeight * pct.yMin);\n    REGION.yMax = Math.floor(innerHeight * pct.yMax);\n  }\n  \n  function resize() {\n  \n    const isCoarse = matchMedia('(pointer: coarse)').matches;\n    const DPR_CAP = isCoarse ? 1.25 : 1.75;   // tighter on phones/tablets\n    const dpr = Math.min(DPR_CAP, Math.max(1, devicePixelRatio || 1));\n  \n    W = canvas.width  = Math.floor(innerWidth  * DPR);\n    H = canvas.height = Math.floor(innerHeight * DPR);\n    canvas.style.width = innerWidth + 'px';\n    canvas.style.height = innerHeight + 'px';\n    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);\n  \n    computeRegionPixels();\n  \n    // Adaptive density (giant windows get fewer particles)\n    const px = innerWidth * innerHeight;\n    let density = CONFIG.density;\n    if (px > 2_000_000) density *= 0.85;\n    if (px > 3_500_000) density *= 0.70;\n  \n    // build particles by layers\n    particles = [];\n    layerIndexOffsets = [];\n    const totalCount = Math.max(8, Math.floor(innerWidth * innerHeight * density));\n    const layerWeights = CONFIG.layers.map((_, i) => 1 / (i + 1));\n    const weightSum = layerWeights.reduce((a, b) => a + b, 0);\n  \n    let idx = 0;\n    CONFIG.layers.forEach((layer, i) => {\n      const count = Math.max(8, Math.floor(totalCount * (layerWeights[i] / weightSum)));\n      layerIndexOffsets.push(idx);\n      for (let k = 0; k < count; k++) {\n        const zb = CONFIG.depthZBias || 1;\n        const z  = 1 - Math.pow(Math.random(), zb); // 0 (far) .. 1 (near)\n        particles.push({\n          layer: i,\n          x: rand(REGION.xMin, REGION.xMax),\n          y: rand(REGION.yMin, REGION.yMax),\n          vx: 0, vy: 0,\n          seed: Math.random() * 1000,\n          z,\n          r0: rand(layer.size[0], layer.size[1])\n        });   \n        idx++;\n      }\n    });\n    // Sort indices by depth once (far → near) so near draws last (on top)\n    drawOrder = particles.map((_, idx) => idx).sort((a, b) => particles[a].z - particles[b].z);\n    // Cache gradient once per resize (instead of every frame)\n    cachedGrad = null;\n  }\n  \n  function contain(p) {\n    if (!CONFIG.containToRegion) return;\n  \n    // --- Wrap modes ---\n    if (CONFIG.containMode === 'wrap' || CONFIG.containMode === 'wrapX') {\n      // horizontal wrap\n      if (p.x < REGION.xMin) p.x = REGION.xMax - 1;\n      else if (p.x > REGION.xMax) p.x = REGION.xMin + 1;\n  \n      if (CONFIG.containMode === 'wrap') {\n        // vertical wrap too\n        if (p.y < REGION.yMin) p.y = REGION.yMax - 1;\n        else if (p.y > REGION.yMax) p.y = REGION.yMin + 1;\n      } else {\n        // for wrapX, just clamp vertical\n        p.y = Math.min(Math.max(p.y, REGION.yMin), REGION.yMax);\n      }\n      return;\n    }\n  \n    // --- Soft steer mode (Option B uses this) ---\n    if (CONFIG.containMode === 'steer') {\n      const m = CONFIG.wallMargin || 6;\n      const f = CONFIG.wallForce  || 0.03;\n      if (p.x < REGION.xMin + m) p.vx += f;\n      if (p.x > REGION.xMax - m) p.vx -= f;\n      if (p.y < REGION.yMin + m) p.vy += f;\n      if (p.y > REGION.yMax - m) p.vy -= f;\n    }\n  \n    // safety clamp for steer/bounce\n    p.x = Math.min(Math.max(p.x, REGION.xMin), REGION.xMax);\n    p.y = Math.min(Math.max(p.y, REGION.yMin), REGION.yMax);\n  \n    if (CONFIG.containMode === 'bounce') {\n      if (p.x <= REGION.xMin || p.x >= REGION.xMax) p.vx *= -1;\n      if (p.y <= REGION.yMin || p.y >= REGION.yMax) p.vy *= -1;\n    }\n  }\n  \n  \n  let cachedGrad = null;\n  function gradientForRegion() {\n    if (!cachedGrad) {\n      const g = ctx.createLinearGradient(REGION.xMin, 0, REGION.xMax, 0);\n      g.addColorStop(0, CONFIG.dotColorA);\n      g.addColorStop(1, CONFIG.dotColorB);\n      cachedGrad = g;\n    }\n    return cachedGrad;\n  }\n  \n      function drawRunner(pa, pb, tNorm, zPair, baseAlpha = 1) {\n    // tNorm is 0..1 along the line from pa -> pb\n    const x = lerp(pa.x, pb.x, tNorm);\n    const y = lerp(pa.y, pb.y, tNorm);\n  \n    // Depth scaling (nearer links: slightly bigger/brighter)\n    const size = (BGNet.config.runnerSize || 2) * (0.8 + 0.4 * zPair);\n  \n    // Optional “streak” segment around the runner\n    const tailFrac = Math.max(0, BGNet.config.runnerTail || 0.10);\n    const half = tailFrac * 0.5;\n    const t0 = Math.max(0, tNorm - half);\n    const t1 = Math.min(1, tNorm + half);\n  \n    // Compute tail endpoints (short bright sub-segment on the link)\n    const x0 = lerp(pa.x, pb.x, t0), y0 = lerp(pa.y, pb.y, t0);\n    const x1 = lerp(pa.x, pb.x, t1), y1 = lerp(pa.y, pb.y, t1);\n  \n    // Tail (thin bright stroke with additive blend)\n    const prevComp = ctx.globalCompositeOperation;\n    const prevBlur = ctx.shadowBlur;\n    const prevAlpha = ctx.globalAlpha;\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.shadowBlur = BGNet.config.runnerGlow || 8;\n    ctx.globalAlpha = Math.min(1, 0.9 * baseAlpha * (0.6 + 0.6 * zPair));\n    ctx.lineWidth = Math.max(1, 1.2 + 1.2 * zPair);\n    ctx.strokeStyle = BGNet.config.runnerColor || '#FFE69A';\n    ctx.beginPath();\n    ctx.moveTo(x0, y0);\n    ctx.lineTo(x1, y1);\n    ctx.stroke();\n  \n    // Packet head (small glowing dot)\n    ctx.beginPath();\n    ctx.arc(x, y, size, 0, Math.PI * 2);\n    ctx.fillStyle = BGNet.config.runnerColor || '#FFE69A';\n    ctx.fill();\n  \n    // restore\n    ctx.globalCompositeOperation = prevComp;\n    ctx.shadowBlur = prevBlur;\n    ctx.globalAlpha = prevAlpha;\n  }\n  \n  function step(ts) {\n    if (pauseReasons.size > 0) {\n      rafId = 0;\n      return;\n    }\n    const now = ts || 0;\n    const dt = Math.min(0.033, (now - (lastTs || now)) * 0.001) || 0.016; // clamp @ ~30 FPS\n    t = now * 0.001;  // absolute time for the field\n    lastTs = now;\n  \n    // Smooth pointer\n    const k = CONFIG.parallaxFollow || 0.08;\n    mouse.sx += (mouse.x - mouse.sx) * k;\n    mouse.sy += (mouse.y - mouse.sy) * k;\n  \n    // Parallax vector from center (-1..1)\n    const vx = (mouse.sx - 0.5) * 2;\n    const vy = (mouse.sy - 0.5) * 2;\n  \n    ctx.clearRect(0, 0, innerWidth, innerHeight);\n    ctx.globalCompositeOperation = 'source-over';\n  \n  \n    // slight parallax shift\n    const parX = vx * CONFIG.parallaxStrength * 0.5;\n    const parY = vy * CONFIG.parallaxStrength * 0.5;\n  \n    // Glow\n    ctx.shadowBlur = CONFIG.glow;\n    ctx.shadowColor = 'rgba(255,223,130,0.45)';\n  \n    const grad = gradientForRegion();\n  \n    // Move & draw particles per layer (front to back for nicer overlap)\n    for (let i = 0; i < particles.length; i++) {\n      const p = particles[i];\n      const L = CONFIG.layers[p.layer];\n  \n      // Seeded flow so neighbors don't all move as one\n      const { vx: fx, vy: fy } = flowVec(\n        p.x + p.seed * 13.7,\n        p.y - p.seed * 9.1,\n        t,\n        CONFIG.fieldScale,\n        CONFIG.fieldSpeed * L.speed\n      );\n  \n      // Optional micro-jitter for extra organic motion\n      if (CONFIG.jitter) {\n        p.vx += (Math.random() - 0.5) * CONFIG.jitter;\n        p.vy += (Math.random() - 0.5) * CONFIG.jitter;\n      }\n  \n      // Pure flow + damping (no anchor)\n      const damp = Math.pow(CONFIG.damping, dt * 60);                     // time-scaled damping\n      const gain = (CONFIG.flowStrength * L.speed) * (dt * 60);           // time-scaled push\n      p.vx = p.vx * damp + fx * gain;\n      p.vy = p.vy * damp + fy * gain;\n  \n  \n      // --- cap particle speed so they never accelerate indefinitely ---\n      const sp = Math.hypot(p.vx, p.vy);\n      if (sp > CONFIG.maxSpeed) {\n        const s = CONFIG.maxSpeed / sp;\n        p.vx *= s;\n        p.vy *= s;\n      }\n  \n      // Integrate\n      p.x += p.vx;\n      p.y += p.vy;\n  \n      // Keep inside region using chosen mode\n      contain(p);\n  \n      // --- Depth-based particle drawing ---\n      const z = p.z || 0;\n      const [sMin, sMax] = CONFIG.depthSizeRange || [0.8, 1.6];\n      const r = CONFIG.depthEnabled ? p.r0 * (sMin + (sMax - sMin) * z) : p.r0;\n  \n      const [aMin, aMax] = CONFIG.depthAlphaRange || [0.65, 1];\n      let dotAlpha = CONFIG.depthEnabled ? (aMin + (aMax - aMin) * z) : 1;\n  \n      // --- Twinkle modulation ---\n      if (CONFIG.twinkleEnabled) {\n        const phase = (p.seed * 50.0 + t * CONFIG.twinkleSpeed) % (2 * Math.PI);\n        const twinkle = 0.5 + 0.5 * Math.sin(phase);\n        const nearBoost = 1 + CONFIG.twinkleDepthBoost * z;\n        const twinkleAmt = 1 + CONFIG.twinkleIntensity * (twinkle * nearBoost - 0.5);\n        dotAlpha *= twinkleAmt;\n      }\n      dotAlpha = Math.max(0, Math.min(1, dotAlpha)); // clamp 0–1\n  \n      // optional blur (farther = blurrier)\n      const blurPx = CONFIG.depthEnabled ? (1 - z) * (CONFIG.depthBlurMax || 1.8) : 0;\n      const prevFilter = ctx.filter;\n      if (blurPx > 0.01) ctx.filter = `blur(${blurPx.toFixed(2)}px)`;\n  \n      // parallax shift: near moves more than far, away from pointer direction\n      let rx = p.x, ry = p.y;\n      if (CONFIG.parallaxEnabled) {\n        const s = CONFIG.parallaxStrength || 18;\n        const amt = (p.z - 0.5) * s;\n        rx += -vx * amt;     // move opposite to pointer offset (camera-like)\n        ry += -vy * amt;\n      }\n  \n      // draw\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);\n      ctx.globalAlpha = dotAlpha;\n  \n      // always paint with the gold gradient; twinkle is handled in dotAlpha\n      ctx.fillStyle = grad;\n  \n      // ✅ draw the particle\n      ctx.fill();\n  \n      // --- Metallic specular highlight ---\n      if (CONFIG.twinkleEnabled) {\n        // use twinkle for brightness modulation\n        const phase = (p.seed * 50.0 + t * CONFIG.twinkleSpeed) % (2 * Math.PI);\n        const twinkle = 0.5 + 0.5 * Math.sin(phase);\n        const zBoost = 0.75 + 0.25 * z;\n        const specAmt = (twinkle * zBoost) * CONFIG.specularScale;\n  \n        // compute highlight center toward lightDir\n        const lx = CONFIG.lightDir.x, ly = CONFIG.lightDir.y;\n        const hx = p.x + r * lx * 0.4;\n        const hy = p.y + r * ly * 0.4;\n  \n        // small radial gradient: white core → warm gold\n        const g = ctx.createRadialGradient(hx, hy, 0, hx, hy, r * CONFIG.specularSize);\n        g.addColorStop(0, `rgba(255,255,255,${0.20 + 0.6 * specAmt})`);\n        const edgeG = Math.floor(210 + 40 * CONFIG.specularWarmth);\n        const edgeB = Math.floor(120 + 30 * CONFIG.specularWarmth);\n        g.addColorStop(1, `rgba(255,${edgeG},${edgeB},${0.08 + 0.3 * specAmt})`);\n  \n        // draw additively so it glows like metal\n        const prevOp = ctx.globalCompositeOperation;\n        const prevBlur = ctx.shadowBlur;\n        ctx.globalCompositeOperation = 'lighter';\n        ctx.shadowBlur = 0;\n        ctx.beginPath();\n        ctx.arc(hx, hy, r * CONFIG.specularSize, 0, Math.PI * 2);\n        ctx.fillStyle = g;\n        ctx.fill();\n        ctx.globalCompositeOperation = prevOp;\n        ctx.shadowBlur = prevBlur;\n  \n        // --- Tiny star on peak ---\n        if (twinkle > CONFIG.sparkleThreshold) {\n          const arms = 4;\n          const len = r * CONFIG.sparkleSize * (0.8 + 0.3 * z);\n          const alpha = 0.25 + 0.3 * (twinkle - CONFIG.sparkleThreshold) /\n                        (1 - CONFIG.sparkleThreshold);\n          const prevOp2 = ctx.globalCompositeOperation;\n          ctx.globalCompositeOperation = 'lighter';\n          ctx.lineWidth = Math.max(0.6, r * 0.35);\n          ctx.strokeStyle = `rgba(255,235,170,${alpha.toFixed(3)})`;\n          ctx.beginPath();\n          ctx.moveTo(p.x - len, p.y); ctx.lineTo(p.x + len, p.y);\n          ctx.moveTo(p.x, p.y - len); ctx.lineTo(p.x, p.y + len);\n          ctx.stroke();\n          ctx.globalCompositeOperation = prevOp2;\n        }\n      }\n  \n  \n      // restore state\n      ctx.globalAlpha = 1;\n      if (blurPx > 0.01) ctx.filter = prevFilter;\n  \n    }\n  \n    // Connections (do per-layer for performance & look)\n    for (let li = 0; li < CONFIG.layers.length; li++) {\n      const start = layerIndexOffsets[li];\n      const end   = (li + 1 < layerIndexOffsets.length) ? layerIndexOffsets[li + 1] : particles.length;\n      const L = CONFIG.layers[li];\n      for (let a = start; a < end; a++) {\n        const pa = particles[a];\n        let links = 0, maxLinks =4;  // cap per particle\n        let drewAny = false;      // did we draw at least one normal link?\n        let nearest = [];         // stores [distance, index] pairs\n        for (let b = a + 1; b < end; b++) {\n          const pb = particles[b];\n          const dx = pa.x - pb.x;\n          const dy = pa.y - pb.y;\n          const dist = Math.hypot(dx, dy);\n          if ((CONFIG.kNearest|0) > 0) {\n            if (nearest.length < CONFIG.kNearest) {\n              nearest.push([dist, b]);\n              nearest.sort((u, v) => u[0] - v[0]); // keep sorted by distance\n            } else if (dist < nearest[nearest.length - 1][0]) {\n              nearest[nearest.length - 1] = [dist, b];\n              nearest.sort((u, v) => u[0] - v[0]);\n            }\n          }\n          if (dist < L.linkDist) {\n            // --- Depth-based link drawing ---\n            const zPair = ((pa.z || 0) + (pb.z || 0)) * 0.5;\n  \n            const baseAlpha = Math.max(0.06, Math.min(1, (1 - dist / L.linkDist) * (L.linkAlpha || 0.65)));\n            const depthBoost = 0.50 + 0.80 * zPair;  // near => alpha\n            const alpha = Math.min(1, baseAlpha *depthBoost);\n            const [wFar, wNear] = CONFIG.depthLinkWidth || [0.6, 2.6];\n            const width = wFar + (wNear - wFar) * zPair;\n            \n            const gate = Math.pow(baseAlpha, 1.5) * 0.85;\n            if (pairRand(a, b) >= gate) continue;\n            ctx.lineWidth = width;\n            const lineColor = (window.BGNet?.config?.lineColor) || CONFIG.lineColor || '#FFDF8A';\n            ctx.strokeStyle = lineColor.replace('ALPHA', alpha.toFixed(3));\n            // Render positions with parallax applied\n            let pax = pa.x, pay = pa.y, pbx = pb.x, pby = pb.y;\n            if (CONFIG.parallaxEnabled) {\n              const s = CONFIG.parallaxStrength || 18;\n              const za = (pa.z - 0.5) * s, zb = (pb.z - 0.5) * s;\n              pax += -vx * za; pay += -vy * za;\n              pbx += -vx * zb; pby += -vy * zb;\n            }\n            ctx.beginPath();\n            ctx.moveTo(pax, pay);\n            ctx.lineTo(pbx, pby);\n            ctx.stroke();\n            if (CONFIG.runnersEnabled) {\n              const seed = pairSeed(a, b);\n              const zPair = ((pa.z || 0) + (pb.z || 0)) * 0.5;\n              const spd = (CONFIG.runnerSpeed || 0.3) * (0.9 + 0.2 * zPair);\n              const tNorm = (seed + t * spd) % 1;\n              drawRunner(pa, pb, tNorm, zPair, alpha);\n              drawRunner({x:pax,y:pay},{x:pbx,y:pby}, tNorm, zPair, alpha);\n            }\n  \n  \n            ctx.globalAlpha = 1;           // <-- keep this right after stroke()\n  \n            drewAny = true;  // mark that a “real” link was drawn\n            if (++links >= maxLinks) break;\n  \n          }\n        }\n        if (CONFIG.keepConnected && (CONFIG.kNearest|0) > 0) {\n          // how many fallback lines to add (if normal links were scarce)\n          const need = Math.max(0, (CONFIG.kNearest|0) - (drewAny ? 1 : 0));\n  \n          for (let i = 0; i < nearest.length && i < need; i++) {\n            const nbIndex = nearest[i][1];\n            const pb = particles[nbIndex];\n            const baseDist = nearest[i][0];\n  \n            // Give a little extra reach so fallback has something to connect to\n            const reach = (L.linkDist || 120) + (CONFIG.extraReach || 0);\n  \n            // Alpha fades with distance but never below minLinkAlpha\n            const distNorm = 1 - Math.min(1, baseDist / reach);\n            const alpha = Math.max(CONFIG.minLinkAlpha || 0.18, distNorm * (L.linkAlpha || 0.65));\n  \n            const lineColor = BGNet.config.lineColor || '#FFDF8A';\n            ctx.lineWidth = 1.0 + 1.2 * alpha; // a hair subtler than normal links\n            ctx.strokeStyle = lineColor.replace('ALPHA', alpha.toFixed(3));\n            ctx.beginPath();\n            ctx.moveTo(pa.x, pa.y);\n            ctx.lineTo(pb.x, pb.y);\n            ctx.stroke();\n          }\n        }\n      }\n    }\n  \n    // Optional triangle mesh accents (light, random)\n    if (CONFIG.drawTriangles) {\n      const start = layerIndexOffsets[0] || 0;\n      const end   = layerIndexOffsets[1] || Math.min(particles.length, start + 60);\n      for (let i = start; i + 2 < end; i += 3) {\n        const i = drawOrder[oi];\n        const p1 = particles[i], p2 = particles[i+1], p3 = particles[i+2];\n        ctx.beginPath();\n        ctx.moveTo(p1.x - parX, p1.y - parY);\n        ctx.lineTo(p2.x - parX, p2.y - parY);\n        ctx.lineTo(p3.x - parX, p3.y - parY);\n        ctx.closePath();\n        ctx.fillStyle = `rgba(255,255,255,${CONFIG.triangleAlpha})`;\n        ctx.fill();\n      }\n    }\n  \n    rafId = requestAnimationFrame(step);\n  }\n  \n  // Boot\n  resize();\n  addEventListener('resize', resize);\n  \n  const applyEnvironmentConfig = () => {\n    const applyPreset = (preset) => {\n      if (!preset) return;\n      if (typeof preset.density === 'number') {\n        CONFIG.density = preset.density;\n      }\n      if (typeof preset.glow === 'number') {\n        CONFIG.glow = preset.glow;\n      }\n      if (typeof preset.linkAdjust === 'number') {\n        CONFIG.layers.forEach((layer) => {\n          const base = layer.linkDist ?? 120;\n          layer.linkDist = Math.max(60, base + preset.linkAdjust);\n        });\n      }\n      if (typeof preset.linkDist === 'number') {\n        CONFIG.layers.forEach((layer) => {\n          layer.linkDist = preset.linkDist;\n        });\n      }\n    };\n\n    const basePreset = { density: 0.00009, glow: 4, linkAdjust: -8 };\n    applyPreset(basePreset);\n\n    const loadPreset = { density: 0.00013, glow: 8, linkDist: 110 };\n    applyPreset(loadPreset);\n\n    CONFIG.fieldSpeed = 0.00020;\n    CONFIG.flowStrength = 0.40;\n    CONFIG.damping = 0.995;\n    CONFIG.layers.forEach((layer, index) => {\n      const scale = index === 0 ? 0.80 : 0.70;\n      layer.speed *= scale;\n    });\n\n    const hiDPI = (window.devicePixelRatio || 1) > 2;\n    if (hiDPI) {\n      CONFIG.density        = Math.min(CONFIG.density, 0.00005);\n      CONFIG.glow           = Math.min(CONFIG.glow ?? 8, 6);\n      CONFIG.runnerGlow     = Math.min(CONFIG.runnerGlow ?? 8, 6);\n      CONFIG.runnersPerLink = Math.min(CONFIG.runnersPerLink ?? 2, 1);\n      CONFIG.runnerSpeed    = Math.min(CONFIG.runnerSpeed ?? 0.3, 0.22);\n      CONFIG.flowStrength   = Math.min(CONFIG.flowStrength ?? 0.04, 0.028);\n    }\n\n    const css = getComputedStyle(document.documentElement);\n    const gold1 = (css.getPropertyValue('--gold-1').trim()) || '#FFD166';\n    const gold2 = (css.getPropertyValue('--gold-2').trim()) || '#F5B000';\n    const goldL = (css.getPropertyValue('--gold-line').trim()) || '#FFDF8A';\n\n    const hexToRgba = (hex, alpha = 1) => {\n      if (!/^#([0-9a-fA-F]{6})$/.test(hex)) return hex;\n      const r = parseInt(hex.slice(1, 3), 16);\n      const g = parseInt(hex.slice(3, 5), 16);\n      const b = parseInt(hex.slice(5, 7), 16);\n      return `rgba(${r},${g},${b},${alpha})`;\n    };\n\n    CONFIG.dotColorA = hexToRgba(gold1, 0.82);\n    CONFIG.dotColorB = hexToRgba(gold2, 0.82);\n    const lineColor = hexToRgba(goldL, 1);\n    CONFIG.lineColor = typeof lineColor === 'string'\n      ? lineColor.replace(/,1\\)$/, ',ALPHA)')\n      : '#FFDF8A';\n\n    if (window.BGNet?.setMode) {\n      window.BGNet.setMode('custom');\n    } else {\n      resize();\n    }\n  };\n\n  // Expose a tiny API so you can tweak live from the console\n  window.BGNet = {\n    setMode: (mode) => { regionMode = mode; resize(); },\n    setCustomPercents: (p) => {\n      customRegionPercents.xMin = p.xMin ?? customRegionPercents.xMin;\n      customRegionPercents.xMax = p.xMax ?? customRegionPercents.xMax;\n      customRegionPercents.yMin = p.yMin ?? customRegionPercents.yMin;\n      customRegionPercents.yMax = p.yMax ?? customRegionPercents.yMax;\n      regionMode = 'custom'; resize();\n    },\n    pause: () => setPaused(manualPauseKey, true),\n    resume: () => setPaused(manualPauseKey, false),\n    isRunning: () => pauseReasons.size === 0 && !!rafId,\n    config: CONFIG,\n    region: () => ({ ...REGION })\n  };\n\n  applyEnvironmentConfig();\n\n  const handleLowPowerChange = (event) => {\n    const matches = event.matches;\n    if (matches) {\n      canvas.dataset.bgNetDisabled = 'true';\n    } else {\n      delete canvas.dataset.bgNetDisabled;\n    }\n    setPaused('low-power', matches);\n  };\n\n  handleLowPowerChange(lowPowerQuery);\n  if (typeof lowPowerQuery.addEventListener === 'function') {\n    lowPowerQuery.addEventListener('change', handleLowPowerChange);\n  } else if (typeof lowPowerQuery.addListener === 'function') {\n    lowPowerQuery.addListener(handleLowPowerChange);\n  }\n\n  const reduceMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n  const handleMotionChange = (event) => setPaused('reduced-motion', event.matches);\n\n  handleMotionChange(reduceMotionQuery);\n  if (typeof reduceMotionQuery.addEventListener === 'function') {\n    reduceMotionQuery.addEventListener('change', handleMotionChange);\n  } else if (typeof reduceMotionQuery.addListener === 'function') {\n    reduceMotionQuery.addListener(handleMotionChange);\n  }\n\n  if (navigator.connection && navigator.connection.saveData === true) {\n    setPaused('save-data', true);\n  }\n\n  const updateVisibility = () => {\n    setPaused('visibility', document.visibilityState !== 'visible');\n  };\n\n  document.addEventListener('visibilitychange', updateVisibility);\n  updateVisibility();\n\n  updateLoop();\n}\n"
  ],
  "names": [],
  "mappings": "AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AAGA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAIA;AACA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA"
}
